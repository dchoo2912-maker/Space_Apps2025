<!-- SAME HEAD + STYLES as you pasted above -->

<script>
// ---------- Main Scene ----------
const canvas = document.getElementById('planet-canvas');
const renderer = new THREE.WebGLRenderer({ antialias:true, canvas });
renderer.setSize(canvas.clientWidth||innerWidth, canvas.clientHeight||innerHeight, false);
renderer.setPixelRatio(Math.min(devicePixelRatio||1, 2));
if ('outputColorSpace' in renderer) renderer.outputColorSpace = THREE.SRGBColorSpace; else renderer.outputEncoding = THREE.sRGBEncoding;
renderer.toneMapping = THREE.ACESFilmicToneMapping;

function resizeRendererToDisplaySize(){
  const w = canvas.clientWidth || innerWidth, h = canvas.clientHeight || innerHeight;
  if(canvas.width !== Math.floor(w*renderer.getPixelRatio()) || canvas.height !== Math.floor(h*renderer.getPixelRatio())){
    renderer.setSize(w,h,false); camera.aspect=w/h; camera.updateProjectionMatrix();
  }
}
window.addEventListener('resize', resizeRendererToDisplaySize);

const scene = new THREE.Scene(); scene.background = new THREE.Color(0x000000);
const camera = new THREE.PerspectiveCamera(60, innerWidth/innerHeight, 0.1, 5000);
camera.position.set(0,30,110);
const controls = new THREE.OrbitControls(camera, canvas);
controls.enableDamping = true; controls.dampingFactor = 0.06; controls.enablePan = false;

// Lights + Sun
scene.add(new THREE.AmbientLight(0xffffff, 0.38));
scene.add(new THREE.HemisphereLight(0xbfdfff, 0x080820, 0.28));
const sunLight = new THREE.PointLight(0xffffff, 2.1, 0); sunLight.position.set(0,0,0); scene.add(sunLight);

// TEXTURES
const TEXSRC = {
  sun:"textures/sun.jpg",
  mercury:"textures/mercury.jpg", venus:"textures/venus.jpg", earth:"textures/earth.jpg",
  moon:"textures/moon.jpg", mars:"textures/mars.jpg", jupiter:"textures/jupiter.jpg",
  saturn:"textures/saturn.jpg", saturnRing:"textures/saturn_ring.png",
  uranus:"textures/uranus.jpg", neptune:"textures/neptune.jpg"
};
const texLoader = new THREE.TextureLoader();

// SUN (with texture)
const sun = new THREE.Mesh(
  new THREE.SphereGeometry(3, 64, 48),
  new THREE.MeshBasicMaterial({ map: texLoader.load(TEXSRC.sun) })
);
scene.add(sun);

// Planet defs
const planetDefs = [
  {name:'Mercury', radius:0.38, dist:5, orbitSpeed:0.040, tiltDeg:0.03, key:'mercury', spinHours:1407.5},
  {name:'Venus',   radius:0.95, dist:7, orbitSpeed:0.015, tiltDeg:177.4, key:'venus',   spinHours:-5832.5},
  {name:'Earth',   radius:1.00, dist:10, orbitSpeed:0.010, tiltDeg:23.4,  key:'earth',   spinHours:24},
  {name:'Mars',    radius:0.53, dist:15, orbitSpeed:0.0053,tiltDeg:25.2,  key:'mars',    spinHours:24.6},
  {name:'Jupiter', radius:1.50, dist:25, orbitSpeed:0.00084,tiltDeg:3.1,  key:'jupiter', spinHours:9.9},
  {name:'Saturn',  radius:1.20, dist:35, orbitSpeed:0.00034,tiltDeg:26.7, key:'saturn',  spinHours:10.7},
  {name:'Uranus',  radius:1.00, dist:45, orbitSpeed:0.00012,tiltDeg:97.8, key:'uranus',  spinHours:-17.2},
  {name:'Neptune', radius:1.00, dist:55, orbitSpeed:0.00006,tiltDeg:28.3, key:'neptune', spinHours:16.1}
];

const planets=[], clickables=[], ringsToFollow=[], planetMeshesByName={};
const SPIN_SCALE = 0.5 / (24*3600);

function addPlanet(def){
  const mesh = new THREE.Mesh(new THREE.SphereGeometry(def.radius,64,48), new THREE.MeshPhongMaterial());
  mesh.rotation.z = THREE.MathUtils.degToRad(def.tiltDeg);
  mesh.userData = {
    name:def.name, dist:def.dist, theta:Math.random()*Math.PI*2,
    orbitSpeed:def.orbitSpeed, spinRadPerSec:(2*Math.PI/(Math.abs(def.spinHours)*3600))*(def.spinHours<0?-1:1)*SPIN_SCALE
  };
  mesh.position.set(def.dist*Math.cos(mesh.userData.theta),0,def.dist*Math.sin(mesh.userData.theta));
  scene.add(mesh); planets.push(mesh); clickables.push(mesh); planetMeshesByName[def.name]=mesh;

  // Texture
  texLoader.load(TEXSRC[def.key], t=>{
    t.colorSpace=THREE.SRGBColorSpace; mesh.material.map=t; mesh.material.needsUpdate=true;
  });

  // Saturn rings
  if(def.name==='Saturn'){
    const ringGeo=new THREE.RingGeometry(def.radius*2.1, def.radius*3.5, 128);
    const ringMat=new THREE.MeshBasicMaterial({
      map: texLoader.load(TEXSRC.saturnRing),
      transparent:true, side:THREE.DoubleSide
    });
    const ring=new THREE.Mesh(ringGeo,ringMat);
    ring.rotation.x=-Math.PI/2; ring.position.copy(mesh.position);
    scene.add(ring); ringsToFollow.push({ring,parent:mesh});
  }
}
planetDefs.forEach(addPlanet);

// Moon (same logic as your code)
const moon=new THREE.Mesh(new THREE.SphereGeometry(0.27,64,48),new THREE.MeshPhongMaterial());
moon.userData={name:'Moon',distFromParent:2.5,theta:Math.random()*Math.PI*2,orbitSpeed:0.08,spinRadPerSec:(2*Math.PI/(655.7*3600))*SPIN_SCALE};
scene.add(moon); clickables.push(moon);
texLoader.load(TEXSRC.moon, t=>{moon.material.map=t; moon.material.needsUpdate=true;});

// Animate
const clock=new THREE.Clock();
function animate(){
  requestAnimationFrame(animate);
  const dt=clock.getDelta();
  planets.forEach(p=>{
    p.userData.theta+=p.userData.orbitSpeed*dt*60;
    p.position.set(p.userData.dist*Math.cos(p.userData.theta),0,p.userData.dist*Math.sin(p.userData.theta));
    p.rotation.y+=p.userData.spinRadPerSec*dt;
  });
  ringsToFollow.forEach(({ring,parent})=> ring.position.copy(parent.position));
  const earth=planetMeshesByName['Earth'];
  moon.userData.theta+=moon.userData.orbitSpeed*dt*60;
  moon.position.set(earth.position.x+moon.userData.distFromParent*Math.cos(moon.userData.theta),0,earth.position.z+moon.userData.distFromParent*Math.sin(moon.userData.theta));
  moon.rotation.y+=moon.userData.spinRadPerSec*dt;
  controls.update(); renderer.render(scene,camera);
}
animate();
</script>





