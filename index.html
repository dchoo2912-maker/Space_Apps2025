<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Solar System — Textured Planets (Drop-in)</title>

<!-- Three.js + OrbitControls -->
<script src="https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.152.2/examples/js/controls/OrbitControls.js"></script>

<style>
  html,body { height:100%; margin:0; background:#000; font-family:system-ui, -apple-system, Segoe UI, Roboto, Inter, Arial; }
  #hud { position:fixed; inset:auto 16px 16px 16px; color:#cdd9ff; font-size:14px; line-height:1.4; }
  #hud code { background:rgba(255,255,255,.08); padding:2px 6px; border-radius:6px; }
</style>
</head>
<body>
<div id="hud">Textures loaded. Toggle orbits by editing <code>ORBIT = true</code> in the script.</div>
<script>
/** ======================
 *  Scene / Camera / Renderer
 *  ====================== */
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x000000);

const camera = new THREE.PerspectiveCamera(55, innerWidth/innerHeight, 0.1, 5000);
camera.position.set(0, 50, 160);

const renderer = new THREE.WebGLRenderer({ antialias:true });
renderer.setSize(innerWidth, innerHeight);
renderer.outputColorSpace = THREE.SRGBColorSpace;
renderer.physicallyCorrectLights = true;
document.body.appendChild(renderer.domElement);

const controls = new THREE.OrbitControls(camera, renderer.domElement);
controls.enableDamping = true;

/** ======================
 *  Lights (sun acts as big point light)
 *  ====================== */
const hemi = new THREE.HemisphereLight(0x445577, 0x000000, 0.15);
scene.add(hemi);

const sunLight = new THREE.PointLight(0xffffff, 3.5, 0, 2);
sunLight.position.set(0,0,0);
scene.add(sunLight);

/** ======================
 *  Texture Loader (single instance)
 *  ====================== */
const loader = new THREE.TextureLoader();

const textures = {
  sun:     loader.load("https://threejsfundamentals.org/threejs/resources/images/sun.jpg"),
  mercury: loader.load("https://threejsfundamentals.org/threejs/resources/images/mercury.jpg"),
  venus:   loader.load("https://threejsfundamentals.org/threejs/resources/images/venus.jpg"),
  earth:   loader.load("https://threejsfundamentals.org/threejs/resources/images/earth.jpg"),
  moon:    loader.load("https://threejsfundamentals.org/threejs/resources/images/moon.jpg"),
  mars:    loader.load("https://threejsfundamentals.org/threejs/resources/images/mars.jpg"),
  jupiter: loader.load("https://threejsfundamentals.org/threejs/resources/images/jupiter.jpg"),
  saturn:  loader.load("https://threejsfundamentals.org/threejs/resources/images/saturn.jpg"),
  uranus:  loader.load("https://threejsfundamentals.org/threejs/resources/images/uranus.jpg"),
  neptune: loader.load("https://threejsfundamentals.org/threejs/resources/images/neptune.jpg"),
};

/** Ensure sRGB for color textures */
Object.values(textures).forEach(t => t.colorSpace = THREE.SRGBColorSpace);

/** ======================
 *  Helpers
 *  ====================== */
function createPlanet({ name, radius, distance, texture, emissive = 0x000000 }) {
  const geo = new THREE.SphereGeometry(radius, 64, 64);
  const mat = new THREE.MeshPhongMaterial({ map: texture, emissive });
  const mesh = new THREE.Mesh(geo, mat);
  mesh.position.x = distance;
  mesh.userData = { name, radius, distance, theta: Math.random()*Math.PI*2, speed: 0 };
  return mesh;
}

/** Saturn ring (transparent) generated in-code (no external PNG) */
function makeRingTexture(size = 1024) {
  const c = document.createElement('canvas');
  c.width = c.height = size;
  const ctx = c.getContext('2d');
  const grad = ctx.createRadialGradient(size/2, size/2, size*0.15, size/2, size/2, size*0.48);
  // Soft banding: opaque rings → fade to transparent
  grad.addColorStop(0.00, "rgba(255,255,255,0.0)");
  grad.addColorStop(0.20, "rgba(255,255,255,0.08)");
  grad.addColorStop(0.35, "rgba(255,255,255,0.18)");
  grad.addColorStop(0.45, "rgba(255,255,255,0.10)");
  grad.addColorStop(0.60, "rgba(255,255,255,0.04)");
  grad.addColorStop(1.00, "rgba(255,255,255,0.0)");
  ctx.fillStyle = grad;
  ctx.beginPath();
  ctx.arc(size/2, size/2, size*0.5, 0, Math.PI*2);
  ctx.arc(size/2, size/2, size*0.15, 0, Math.PI*2, true);
  ctx.fill("evenodd");
  const tex = new THREE.CanvasTexture(c);
  tex.colorSpace = THREE.SRGBColorSpace;
  tex.wrapS = tex.wrapT = THREE.ClampToEdgeWrapping;
  tex.magFilter = THREE.LinearFilter;
  return tex;
}

/** ======================
 *  Build bodies
 *  (sizes/distances *not* to scale; tuned for visibility)
 *  ====================== */
const bodies = [];

// Sun (emissive)
const sunGeo = new THREE.SphereGeometry(16, 64, 64);
const sunMat = new THREE.MeshPhongMaterial({ map: textures.sun, emissive: 0xffaa33, emissiveIntensity: 1.2 });
const sun = new THREE.Mesh(sunGeo, sunMat);
sun.name = "Sun";
scene.add(sun);

// Planets
bodies.push(createPlanet({ name:"Mercury", radius:1.2,  distance:24,  texture:textures.mercury }));
bodies.push(createPlanet({ name:"Venus",   radius:2.0,  distance:32,  texture:textures.venus }));
const earth = createPlanet({ name:"Earth", radius:2.1,  distance:42,  texture:textures.earth });
bodies.push(earth);
const moon  = createPlanet({ name:"Moon",  radius:0.6,  distance:earth.position.x + 4, texture:textures.moon });
bodies.push(moon);
bodies.push(createPlanet({ name:"Mars",    radius:1.6,  distance:52,  texture:textures.mars }));
bodies.push(createPlanet({ name:"Jupiter", radius:7.5,  distance:74,  texture:textures.jupiter }));
const saturn = createPlanet({ name:"Saturn", radius:6.4, distance:96,  texture:textures.saturn });
bodies.push(saturn);
bodies.push(createPlanet({ name:"Uranus",  radius:3.0,  distance:118, texture:textures.uranus }));
bodies.push(createPlanet({ name:"Neptune", radius:3.0,  distance:138, texture:textures.neptune }));

// Set orbital speeds (arbitrary but staggered)
bodies.forEach((b, i) => b.userData.speed = 0.002 + i*0.00025);

// Add to scene
bodies.forEach(b => scene.add(b));

// Saturn rings
{
  const inner = saturn.userData.radius * 1.7;
  const outer = saturn.userData.radius * 2.7;
  const ringGeo = new THREE.RingGeometry(inner, outer, 128, 1);
  // Orient ring: face camera by default, then tilt
  ringGeo.rotateX(-Math.PI/2);
  const ringMat = new THREE.MeshBasicMaterial({
    map: makeRingTexture(1024),
    transparent: true,
    side: THREE.DoubleSide,
    depthWrite: false
  });
  const ring = new THREE.Mesh(ringGeo, ringMat);
  ring.position.copy(saturn.position);
  ring.userData.parent = saturn;
  scene.add(ring);
  saturn.userData.ring = ring;
}

/** ======================
 *  Orbit logic
 *  ====================== */
const ORBIT = true; // <— set to false to disable motion

function updateOrbits(dt) {
  if (!ORBIT) return;

  for (const b of bodies) {
    // Moon gets special orbit around Earth
    if (b.userData.name === "Moon") {
      const r = 4; // moon orbit radius
      b.userData.theta += 0.02 * dt;
      b.position.set(
        earth.position.x + Math.cos(b.userData.theta) * r,
        0,
        Math.sin(b.userData.theta) * r
      );
    } else {
      b.userData.theta += b.userData.speed * dt;
      const r = b.userData.distance;
      b.position.set(Math.cos(b.userData.theta) * r, 0, Math.sin(b.userData.theta) * r);
      // Keep saturn ring with the planet
      if (b === saturn && saturn.userData.ring) {
        saturn.userData.ring.position.copy(saturn.position);
        saturn.userData.ring.rotation.z = b.userData.theta * 0.1; // subtle precession
      }
    }
    // Slow self-rotation
    b.rotation.y += 0.003 * dt;
  }
  // Sun slow spin
  sun.rotation.y += 0.0015 * dt;
}

/** ======================
 *  Animate
 *  ====================== */
let last = performance.now();
function animate(now = performance.now()) {
  const dt = Math.min(60, now - last) * 0.06; // normalized delta
  last = now;

  updateOrbits(dt);
  controls.update();
  renderer.render(scene, camera);
  requestAnimationFrame(animate);
}
animate();

/** ======================
 *  Resize
 *  ====================== */
addEventListener('resize', () => {
  camera.aspect = innerWidth/innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(innerWidth, innerHeight);
});
</script>
</body>
</html>


